# Pointers and Arrays
An array is a fundamental data structure built into C. Array and pointer notations are closely related to each other and can frequently be used interchangeably in the right context. Although array name can be used similar to a pointer it doesn't support all features of pointer. The array's name by itself returns the array's address but it cannot be used by itself as the target of an assignment. The array is stored in contiguous block and consists of homogenous elements (same data type) only. The array size were to be fixed during compile time itself in versions previous to C99. Dynamic arrays were then created using realloc() function.<br>
### Endianness
Endianness describes the format / layout in which the data elements will be stored in the memory. The load / store instructions read data from memory and write data back into memory from registers after some instructions are executed on the data. While storing and loading, the CPU must take care of the endianness followed by the hardware. There exist two kinds of endianness : <br>
1. **Big endianness :** the most significant byte gets stored at the start location and least significant byte at the end location<br>
2. **Small endianness:** the most significant byte gets stored at the end location and least significant byte at the start location<br>
## Pointer Arithmetic
The following arithmetic operations can be performed on pointers pointing to data :<br>
1. **Adding an integer to the pointer**<br>
When an integer is added to a pointer, the actual addition is of integer times size of data type bytes in memory location.<br>
`ptr = ptr + k is equivalent to ptr = ptr + k*sizeof(data_type)`<br>
NOTE: ptr++ is ptr = ptr + 1<br>
2. **Subtracting an integer from the pointer**<br>
When an integer is subtracted from a pointer, the actual subtraction is of integer times size of data type bytes in memory location.<br>
`ptr = ptr - k is equivalent to ptr = ptr - k*sizeof(data_type)`<br>
NOTE: ptr-- is ptr = ptr - 1<br>
3. **Subtracting two pointers**<br>
When two pointer variables are pointing to separate locations within consecutive memory addresses of an array and then they are subtracted from each other, the difference represents the number of elements present between the two pointer variables. This is helpful in determining the order of elements in an array.<br>
`n = ptr2 - ptr1 is equivalent to n = (ptr2 - ptr1)/(sizeof(data_type))`<br>
4. **Comparing two pointers**<br>
Two pointers can be compared using standard comparison operators of C ( ==, !=, >=, <=, >, <).<br>

*Refer to code [12_Pointer_arithmetic.c](https://github.com/parthnakar1/C_pointers/blob/master/Resources/Codes/12_Pointer_arithmetic.c) in /Resources/Codes/ folder for example code*
## Single Dimension Arrays
One dimensionl arrays are linear data structures that stores data in consecutive memory locations. It uses a single index to access its members<br>
Syntax : `data_type array_name[number_of_elements];         // declaration`<br>
The index starts at 0 and ends at number_of_elements - 1. The array_name simply references to starting location of the array block. It stores no information about the number_of_elements. That information can be obtained by following expression : `sizeof(array_name) / sizeof(data_type)`. The array elements can be assigned during declaration or afterwards.<br>
Any element is accessed as follows : `array_name[k]; // k is a valid index integer`. The notation `array_name[k]` is logically evaluated as `*(array_name + k)` where addition takes place as a pointer addition.
### Difference between Pointer and Array
The code generated by `array_name[k]` is different than `*(ptr + k)` (where ptr points to start of the array). The code generated by first notation is pointing to start location of array, moving by k units in memory and then returning the value at that location. While the second notation generates a code where k units are added to ptr and then the value at that location is returned.<br>
While an address pointed by a pointer can be changed the same is not possible when using array_name to point the start location of the array.
### Passing Single Dimensional Arrays
The start address of the array is passed as an argument for passing an array. Since the function gets no information about the size of the array, the number_of_elements too needs to be passed as an argument<br>
Syntax : (array notation)
```
data_type function(data_type array[], int size);    // function declaration
...
data_type array_name[number_of elements];           // array declaration
...
function(array_name, number_of_elements);           // function call
```
Syntax : (pointer notation)
```
data_type function(data_type *ptr, int size);       // function declaration
...
data_type array_name[number_of elements];           // array declaration
data_type *ptr;                                     // pointer declaration
ptr = array_name;                                   // assigning start location of array to ptr
...
function(ptr, number_of_elements);                  // function call
```
*Refer to code [13_Array_basics.c](https://github.com/parthnakar1/C_pointers/blob/master/Resources/Codes/13_Array_basics.c) in /Resources/Codes/ folder for example code*
### Dynamic Array
It may be possible that the size of the array to be created is not known at compile time. An approach to tackle this problem is to create an array of sufficiently large size. But this may lead to lot of memory wastage most of the times. This is dealt with using dynamic arrays. The size of such an array can be changed using realloc(). There can be two ways of using this method :<br>
1. Initially size = 0, each time a new value is added, realloc() is used and size is increased by 1 unit.<br>
2. Create an dynamic array of fixed size, when this space gets used up, realloc() new array of double the previous size.<br>

*Refer to code [14_Dynamic_arrays.c](https://github.com/parthnakar1/C_pointers/blob/master/Resources/Codes/14_Dynamic_arrays.c) in /Resources/Codes/ folder for example code*
## Multidimensional Arrays
The 2-dimensional array is taken everywhere for examples however same rules scan be used for higher dimension arrays as well. Rows and column notation is used to identify array elements in 2-dimensional array. A 2-dimensional array can be visualized as a stack of 1 dimensional arrays. The array's 1<sup>st</sup> row is placed in memory followed by 2<sup>nd</sup> row and so on. It is treated as an array of arrays.<br>
![Memory layout 2d array](/Resources/Images/2d_array.jpg)<br>
*image source : https://eli.thegreenplace.net/2015/memory-layout-of-multi-dimensional-arrays*<br>
Syntax : `data_type array_name[rows][cols];     // declaration`<br>
An element can be accessed as follows : `array_name[i][j]; // i and j are valid integers `. The array indexes are in pairs with 1<sup>st</sup> index ranging from 0 to row_size - 1 and 2<sup>nd</sup> index ranging from 0 to col_size. When only 1 subscript is used, we get a pointer to the corresponding row. The notation `array_name[i][j]` is logically evaluated as `*(array_name + (i*cols) + (j*sizeof(data_type))`.<br>
The array name returns the start address of the 2-dimensional array. Adding 1 to that value adds an offset equal to the size of 1<sup>st</sup> column and not sizeof(data_type).
### Passing Multidimensional Arrays
When passing a multidimensional array, we need to determine whether to use array notation or pointer notation. The shape here refers to size and number of dimensions. For using array notation, it is necessary to specify the shape otherwise the compiler will be unable to use the subscripts.<br>
Syntax :(array notation)
```
data_type function(data_type array[][cols], int rows);      // function declaration
...
data_type array[rows][cols];                                // array declaration
....
function(array,rows);                                       // function call
```
**NOTE**: The 2<sup>nd</sup> subscript, i.e. col_number is specified as row_size is required by the compiler to know number of elements in each row. <br>
Syntax :(pointer notation)
```
data_type function(data_type *ptr, int rows, int cols);     // function declaration
...
data_type array[rows][cols];                                // array declaration
data_type *ptr;                                             // pointer declaration
ptr = array;                                                // assigning start location of array to ptr
....
function(array,rows);                                       // function call
```
*Refer to code [15_2D_arrays.c](https://github.com/parthnakar1/C_pointers/blob/master/Resources/Codes/15_2D_arrays.c) in /Resources/Codes/ folder for example code*
### Dynamic Multidimensional Arrays
While creating 2-dimensional array memory can be allocated such that all elements are placed in contiguous memory locations or elements of a row are placed in continuous memory location but each row may not be placed in contiguous memory locations.
#### 1. Contiguous allocation
The malloc function is used to allocate memory space for all elements. This approach is simpler for memory management and accessing the elements. However it requires a large contiguous memory block.<br>
Syntax : `data_type *ptr = (data_type *) malloc(row_size * col_size * sizeof(data_type));`<br>
*Refer to code [16_2D_dynamic_arrays.c](https://github.com/parthnakar1/C_pointers/blob/master/Resources/Codes/16_2D_dynamic_arrays.c) in /Resources/Codes/ folder for example code*
#### 2. Non-contiguous allocation
In this approach we first create an dynamic array of pointers having total elements equal to number of rows. These pointers then point to row corresponding to their index number. The rows too are created dynamically. This approach uses small blocks of memory available to store individual rows. However memory management and accessing elements requires careful attention.<br>
Syntax :
```
data_type **ptr_arr = (data_type **) malloc(row_size * sizeof(data_type *));
for(int i = 0; i < row_size; i++)
{
    ptr_arr[i] = (data_type *) malloc(col_size * sizeof(data_type *));
}
```